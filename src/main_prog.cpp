#include "main.hpp"
#include "main_prog.hpp"
#include "Timing.hpp"
#include "simple_task.hpp"
#include "can2.0.hpp"
#include "logger.hpp"
#include "can_messages.h"
#include "uart.hpp"
#include "i2c.hpp"
#include "gpio.hpp"
#include "version.hpp"
#include "stmepic.hpp"
#include <queue>

namespace se = stmepic;

std::shared_ptr<se::I2C> i2c1;

std::shared_ptr<se::UART> uart4 = nullptr;
std::shared_ptr<se::CAN> can    = nullptr;

// se::GpioPin gpio_boot_enable(*BOOT_EN_GPIO_Port, BOOT_EN_Pin);

// PA10 - input radio, actual usage
// PB0 - user button, debug only

se::GpioPin gpio_geiger(*GPIOB, GPIO_PIN_0);   // Read geiger input
se::GpioPin gpio_user_led(*GPIOB, GPIO_PIN_2); // Test only!

se::GpioPin gpio_ch4(*GPIOA, GPIO_PIN_3);        // CH 4
se::GpioPin gpio_ch2(*GPIOC, GPIO_PIN_13);       // CH 2
se::GpioPin gpio_ch1(*GPIOC, GPIO_PIN_4);        // CH 1
se::GpioPin gpio_ch3(*GPIOA, GPIO_PIN_2);        // CH 3
se::GpioPin gpio_health_led(*GPIOA, GPIO_PIN_8); // Health LED

se::SimpleTask task_blink;
se::SimpleTask task_relays;
se::SimpleTask task_geiger;

std::queue<uint16_t> CPS_queue;
uint16_t CPM;
float micro_siwert;
uint8_t current_geiger_status = CAN_GEIGER_STATUS_GEIGER_STATUS_FAULT_CHOICE;

bool relay_state[4] = { true, true, true, true }; // Relay states for CH1, CH2, CH3, CH4

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM7 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
extern "C" {
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
  if(htim->Instance == TIM6) {
    se::Ticker::get_instance().irq_update_ticker();
    HAL_IncTick();
  }
  if(htim->Instance == TIM7) {
    HAL_IncTick();
  }
}
}

// THE FUNCTION ABOVE GETS AUTOGENERATED IN main.cpp MAKE SURE TO DELETE IT FROM THERE

float CPS_to_usiev(uint32_t CPS) {
  return CPS * 60 * 0.00332;
}

se::Status init_board(se::SimpleTask &task, void *pvParameters) {
  (void)task;
  (void)pvParameters;
  return se::Status::OK();
}

se::Status task_read_geiger(se::SimpleTask &task, void *pvParameters) {
  (void)task;
  (void)pvParameters;

  // Read hardware timer, add it's value to the CPS_queue, make sure it's not larger than 60
  uint32_t recent_CPS = TIM1->CNT;
  if(CPS_queue.size() >= 60) {
    CPS_queue.pop();
  }
  CPS_queue.push(recent_CPS);
  TIM1->CNT = 0;

  // Calculate the most recent micro_siwert from the most recent read
  micro_siwert = CPS_to_usiev(recent_CPS);

  // Calculate CPM based on the CPS_queue but only after a minute had passed
  if(CPS_queue.size() < 60) {
    current_geiger_status           = CAN_GEIGER_STATUS_GEIGER_STATUS_OK_CHOICE;
    uint16_t CPM_temp               = 0;
    std::queue<uint16_t> temp_queue = CPS_queue;
    while(!temp_queue.empty()) {
      CPM_temp += temp_queue.front();
      temp_queue.pop();
    }
    CPM = CPM_temp;
  }
  return se::Status::OK();
}

se::Status task_blink_led(se::SimpleTask &task, void *pvParameters) {
  (void)task;
  (void)pvParameters;

  gpio_user_led.toggle();
  return se::Status::OK();
}

se::Status task_changed_relays(se::SimpleTask &task, void *pvParameters) {
  (void)task;
  (void)pvParameters;

  // Toggle relays based on the relay_state array
  gpio_ch1.write(relay_state[0]);
  gpio_ch2.write(relay_state[1]);
  gpio_ch3.write(relay_state[2]);
  gpio_ch4.write(relay_state[3]);

  return se::Status::OK();
}

void main_prog() {
  // START ALL INTERRUPTS
  // HAL_NVIC_SetPriority(TIM6_IRQn, 1, 0);
  // HAL_NVIC_EnableIRQ(TIM6_IRQn);

  HAL_TIM_Base_Start_IT(&htim6);

  // INIT LOGGER
  std::string version = std::to_string(VERSION_MAJOR) + "." + std::to_string(VERSION_MINOR) + "." + std::to_string(VERSION_BUILD);
  se::Logger::get_instance().init(se::LOG_LEVEL::LOG_LEVEL_DEBUG, true, nullptr, true, version);

  CAN_FilterTypeDef can_filter;
  can_filter.FilterBank           = 1;
  can_filter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
  can_filter.FilterActivation     = CAN_FILTER_ENABLE;
  can_filter.FilterMode           = CAN_FILTERMODE_IDMASK;
  can_filter.FilterScale          = CAN_FILTERSCALE_16BIT;
  can_filter.FilterIdHigh         = 0x1110;
  can_filter.FilterIdLow          = 0;
  can_filter.FilterMaskIdHigh     = 0xfff0;
  can_filter.FilterMaskIdLow      = 0;
  can_filter.SlaveStartFilterBank = 0;

  STMEPIC_ASSING_TO_OR_HRESET(can, se::CAN::Make(hcan2, can_filter, nullptr, nullptr));


  can->add_callback(CAN_GPIO_SET_FRAME_ID, can_callback_gpio_set, nullptr);
  can->add_callback(CAN_GPIO_READ_FRAME_ID, can_callback_gpio_read, nullptr);
  can->add_callback(CAN_GPIO_STATUS_FRAME_ID, can_callback_gpio_status, nullptr);


  // can->add_callback(CAN_GEIGER_READ_FRAME_ID, can_callback_geiger_read, nullptr);
  // can->add_callback(CAN_GEIGER_STATUS_FRAME_ID, can_callback_geiger_status, nullptr);

  can->hardware_start();
  task_blink.task_init(task_blink_led, nullptr, 100, nullptr, 1000, 2, "Blink", false);
  task_blink.task_run();


  task_relays.task_init(task_changed_relays, nullptr, 10, nullptr, 1000, 2, "Relays", false);
  task_relays.task_run();

  // task_geiger.task_init(task_read_geiger, nullptr, 1000, init_board, 1000, 2, "Geiger", false);
  // task_geiger.task_run();
}